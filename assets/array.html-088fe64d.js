import{_ as e,o as d,c,d as o}from"./app-1ebbceed.js";const a={},r=o('<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h1><h2 id="数组定义" tabindex="-1"><a class="header-anchor" href="#数组定义" aria-hidden="true">#</a> 数组定义:</h2><p>若集合 S 由 n 个元素组成，且 n 个元素之间具有<strong>线性次序</strong>，则可将集合存放在起始位置为 A ，物理位置<strong>连续</strong>的一段存储空间，并称集合 S 为数组（ array ），通常以地址 A 作为数组的标识。具体的，数组<code>A[]</code>中的每一个元素都唯一对应某一下标，在计算机中，大多数从0开始编号，依次是0号、1号、2号、...、n-1号元素，记作：<br> $$ A = { { a_0,a_1,···,a_{n-1} } }$$ 或者 $$ A[0, n) = { A[0], A[1], \\ldots, A[n - 1] } $$</p><h2 id="线性次序" tabindex="-1"><a class="header-anchor" href="#线性次序" aria-hidden="true">#</a> 线性次序:</h2><ul><li>对于任何 <code>0 ≤ i &lt; j &lt; n</code>，<code>A[i]</code> 都是 <code>A[j]</code> 的前驱（predecessor），<code>A[j]</code> 都是 <code>A[i]</code> 的后继（successor）。特别地，对于任何 <code>i ≥ 1</code>，<code>A[i - 1]</code> 称作 <code>A[i]</code> 的直接前驱（intermediate predecessor）; 对于任何 <code>i ≤ n - 2</code>，<code>A[i + 1]</code> 称作 <code>A[i]</code> 的直接后继（intermediate successor）。任一元素的所有前驱构成其前缀（prefix），所有后继构成其后缀（suffix）</li></ul><p>采用这一编号规范，不仅可以使得每个元素都通过下标唯一指代，而且可以使我们直接访问到任一元素。这里所说的“访问”包含读取、修改等基本操作，而“直接”则是指这些操作都可以在常数时间内完成只要从数组所在空间的起始地址A出发，即可根据每一元素的编号，<strong>经过一次乘法运算和一次加法运算</strong>，获得待访问元素的物理地址。具体地，若数组 <code>A[]</code> 存放空间的起始地址为A，且每个元素占用 s 个单位的空间，则元素 <code>A[i]</code> 对应的物理地址为： $$ A + i×s $$ 因其中元素的物理地址与其下标之间满足这种线性关系，故亦称作线性数组（linear array）。</p><h2 id="数组特点" tabindex="-1"><a class="header-anchor" href="#数组特点" aria-hidden="true">#</a> 数组特点</h2>',7),i=[r];function n(s,t){return d(),c("div",null,i)}const l=e(a,[["render",n],["__file","array.html.vue"]]);export{l as default};
